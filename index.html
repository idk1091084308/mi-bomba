<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Drifter - Multiplayer Racing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #111827;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; user-select: none;
        }
        #gameCanvas {
            display: block; width: 100%; height: 100%;
            background-color: #0f172a;
        }
        .ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            pointer-events: auto; padding: 2rem; border-radius: 1rem;
            max-width: 500px; width: 90%;
        }
        .btn {
            width: 100%; padding: 0.75rem; border-radius: 0.5rem; font-weight: bold;
            transition: all 0.2s; margin-bottom: 0.5rem; cursor: pointer;
        }
        .btn-blue { background: #3b82f6; color: white; }
        .btn-blue:hover { background: #2563eb; transform: scale(1.02); }
        .btn-green { background: #10b981; color: white; }
        .btn-green:hover { background: #059669; transform: scale(1.02); }
        .btn-red { background: #ef4444; color: white; }
        .btn-red:hover { background: #dc2626; transform: scale(1.02); }
        
        input, select {
            width: 100%; padding: 0.5rem; margin-bottom: 1rem; border-radius: 0.5rem;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; outline: none;
        }
        option { background: #1f2937; }
        
        #hud {
            position: absolute; top: 0; left: 0; right: 0; padding: 1rem;
            display: flex; justify-content: space-between; pointer-events: none;
            font-size: 1.5rem; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #wrongWayWarning {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #ef4444; font-size: 4rem; font-weight: 900;
            text-shadow: 0 0 20px #ef4444, 2px 2px 0 #000;
            animation: pulse 1s infinite;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.5; transform: translateX(-50%) scale(1.05); }
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="hud" class="hidden">
        <div>Lap: <span id="lapDisplay" class="text-cyan-400">1/3</span></div>
        <div id="positionDisplay" class="text-yellow-400">Pos: 1</div>
        <div id="speedDisplay" class="text-white">0 MPH</div>
    </div>
    
    <div id="wrongWayWarning" class="hidden">WRONG WAY</div>

    <div id="ui-main" class="ui-layer">
        <div class="panel text-center">
            <h1 class="text-4xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">NEON DRIFTER</h1>
            
            <div class="mb-4 text-left">
                <label class="block text-sm text-gray-400 mb-1">Player Name</label>
                <input type="text" id="playerName" value="Racer" maxlength="12">
                
                <label class="block text-sm text-gray-400 mb-1">Underglow Color</label>
                <input type="color" id="carColor" value="#00f0ff" class="h-10 p-1 cursor-pointer">
                
                <label class="block text-sm text-gray-400 mb-1 mt-2">Cosmetic Hat</label>
                <select id="carHat">
                    <option value="none">No Hat</option>
                    <option value="cap">Baseball Cap</option>
                    <option value="tophat">Top Hat</option>
                    <option value="crown">King's Crown</option>
                </select>
            </div>

            <button id="btnSingleplayer" class="btn btn-green mb-2">Singleplayer (Bots)</button>
            <button id="btnMultiplayer" class="btn btn-blue">Online Multiplayer</button>
            <p class="mt-4 text-xs text-gray-500">Controls: WASD / Arrows. Space to Brake. Secret Boost: Y</p>
        </div>
    </div>

    <div id="ui-multiplayer" class="ui-layer hidden">
        <div class="panel text-center">
            <h2 class="text-2xl font-bold mb-4">Multiplayer Rooms</h2>
            <div class="flex gap-2 mb-4">
                <input type="text" id="roomCodeInput" placeholder="Enter Room Code" class="mb-0">
                <button id="btnJoinRoom" class="btn btn-blue w-auto px-4 mb-0">Join</button>
            </div>
            <div class="my-4 border-b border-gray-600"></div>
            <button id="btnCreateRoom" class="btn btn-green">Create New Room</button>
            <button id="btnBackToMain" class="btn btn-red mt-2">Back</button>
        </div>
    </div>

    <div id="ui-lobby" class="ui-layer hidden">
        <div class="panel">
            <h2 class="text-2xl font-bold mb-2">Room: <span id="lobbyRoomCode" class="text-cyan-400"></span></h2>
            
            <div class="mb-4">
                <label class="block text-sm text-gray-400 mb-1">Vote for Map</label>
                <select id="mapVote">
                    <option value="0">Small Map (3 Laps) - Cartoon Curves</option>
                    <option value="1">Medium Map (2 Laps) - Vector Circuit</option>
                    <option value="2">Large Map (1 Lap) - Water Track</option>
                    <option value="3" selected>Epic Map (2 Laps) - Ocean Highway</option>
                </select>
                <p class="text-xs text-gray-400 italic">If votes differ, map is randomized!</p>
            </div>

            <h3 class="font-bold text-gray-300 mb-2 border-b border-gray-600 pb-1">Players (<span id="playerCount">1</span>)</h3>
            <ul id="playerList" class="mb-6 space-y-1 text-sm text-gray-200 min-h-[100px] max-h-[200px] overflow-y-auto">
                <!-- Players injected here -->
            </ul>

            <button id="btnStartGame" class="btn btn-green hidden">Start Game (Host)</button>
            <div id="waitingMsg" class="text-sm text-yellow-400 hidden mb-4 text-center">Waiting for host to start...</div>
            <button id="btnLeaveRoom" class="btn btn-red">Leave Room</button>
        </div>
    </div>

    <div id="ui-postgame" class="ui-layer hidden">
        <div class="panel text-center">
            <h2 class="text-3xl font-black mb-4 text-yellow-400">RACE FINISHED!</h2>
            <p class="text-xl mb-6">You placed: <span id="finalPlacement" class="font-bold text-white">1st</span></p>
            <button id="btnReturnLobby" class="btn btn-blue">Return to Menu</button>
        </div>
    </div>

    <!-- Socket.IO Client for WebSocket Multiplayer -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

    <script type="module">
        // --- BACKEND CONNECTION SETUP ---
        let socket = null;
        let currentRoomId = null, isHost = false;
        let user = { uid: 'player_' + Math.random().toString(36).substring(2, 9) };
        
        const USE_WEBSOCKET = true; // Set to true for WebSocket/Socket.IO multiplayer
        const WEBSOCKET_URL = window.location.origin.includes('localhost') 
            ? 'http://localhost:3000' 
            : window.location.origin;

        // Initialize WebSocket connection
        if (USE_WEBSOCKET) {
            socket = io(WEBSOCKET_URL, {
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 5
            });

            socket.on('connect', () => {
                console.log('Connected to game server:', socket.id);
            });

            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
            });
        }

        const hasFirebaseConfig = false; // Disabled - using WebSocket instead

        // --- MAP DATA & IMAGES ---
        const mapImages = [
            'cartoon-race-track-top-view-curves-finish-line-flat-design-191145231.webp',
            'race-track-top-view-vector-illustration-363570957.webp',
            'speed-race-car-track-above-water-game-speed-race-car-track-map-game-background-vector-cartoon-illustration-circuit-road-240917902.webp',
            'download (2).jpeg' // Ocean Highway Background
        ];

        const MAPS = [
            { name: "Small Oval", laps: 3, trackRadius: 600, width: 250, bg: mapImages[0] },
            { name: "Medium Circuit", laps: 2, trackRadius: 1200, width: 300, bg: mapImages[1] },
            { name: "Large Complex", laps: 1, trackRadius: 2500, width: 400, bg: mapImages[2] },
            { name: "Ocean Highway", laps: 2, trackRadius: 2000, width: 350, bg: mapImages[3] } 
        ];

        let loadedImages = {};
        mapImages.forEach(src => {
            const img = new Image();
            img.src = src; 
            loadedImages[src] = img;
        });

        // Load custom car model
        const carSprite = new Image();
        carSprite.src = 'simple-travel-car-top_view.png';

        // --- GAME ENGINE & STATE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameState = 'MENU'; 
        let gameMode = 'SINGLE'; 
        let currentMapIndex = 0;
        let lastTime = 0;
        let players = {}; 
        let items = [];
        let particles = [];
        let skidmarks = [];
        let localPlayerId = 'local';
        let waypoints = []; 

        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, ' ':false };

        // --- PHYSICS CONSTANTS ---
        const ACCEL = 600;
        const BRAKE = 1000;
        const MAX_SPEED = 1200;
        const FRICTION_FORWARD = 100;
        const FRICTION_LATERAL = 5;
        const STEER_SPEED = 3.5;

        class Car {
            constructor(id, isLocal, name, color, hat, isBot=false) {
                this.id = id;
                this.isLocal = isLocal;
                this.isBot = isBot;
                this.name = name;
                this.color = color;
                this.hat = hat;
                
                this.x = 0;
                this.y = -MAPS[currentMapIndex].trackRadius + 100;
                this.angle = 0;
                this.velocity = { x: 0, y: 0 };
                this.speed = 0;
                this.width = 44;
                this.length = 88;

                // NEW SECTOR-BASED LAP SYSTEM
                this.lap = 1;
                this.currentSector = 0; 
                this.progress = 0; 
                this.finished = false;
                this.placement = 0;
                
                this.superBoostTime = 0;

                this.targetX = this.x;
                this.targetY = this.y;
                this.targetAngle = this.angle;
            }

            update(dt) {
                if (this.finished) return;

                if (this.isLocal && !this.isBot) {
                    this.handleInput(dt);
                } else if (this.isBot) {
                    this.handleBotAI(dt);
                } else {
                    this.x += (this.targetX - this.x) * 10 * dt;
                    this.y += (this.targetY - this.y) * 10 * dt;
                    
                    let diff = this.targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 10 * dt;
                }

                if (this.isLocal || this.isBot) {
                    this.x += this.velocity.x * dt;
                    this.y += this.velocity.y * dt;

                    const speed = Math.hypot(this.velocity.x, this.velocity.y);
                    if (speed > 0) {
                        const dirX = this.velocity.x / speed;
                        const dirY = this.velocity.y / speed;
                        let drag = FRICTION_FORWARD * dt;
                        
                        if (!this.isOnTrack()) drag *= 5;

                        if (speed < drag) {
                            this.velocity.x = 0; this.velocity.y = 0;
                        } else {
                            this.velocity.x -= dirX * drag;
                            this.velocity.y -= dirY * drag;
                        }
                    }

                    const forwardX = Math.cos(this.angle);
                    const forwardY = Math.sin(this.angle);
                    const rightX = -Math.sin(this.angle);
                    const rightY = Math.cos(this.angle);

                    const forwardVel = this.velocity.x * forwardX + this.velocity.y * forwardY;
                    let lateralVel = this.velocity.x * rightX + this.velocity.y * rightY;

                    let grip = FRICTION_LATERAL;
                    if (Math.abs(lateralVel) > 200) grip = 2; 

                    lateralVel *= Math.exp(-grip * dt);

                    this.velocity.x = forwardX * forwardVel + rightX * lateralVel;
                    this.velocity.y = forwardY * forwardVel + rightY * lateralVel;
                    this.speed = forwardVel;

                    if (Math.abs(lateralVel) > 150 && speed > 200) {
                        if (Math.random() < 0.5) {
                            skidmarks.push({ x: this.x, y: this.y, life: 3.0 });
                        }
                    }

                    this.checkLapProgress();
                    this.checkItems();
                }

                if (this.superBoostTime > 0) {
                    this.superBoostTime -= dt;
                    particles.push({x: this.x, y: this.y, vx: -Math.cos(this.angle)*500, vy: -Math.sin(this.angle)*500, life: 0.5, color: '#ff00ff', size: 5});
                }
            }

            handleInput(dt) {
                const up = keys.w || keys.ArrowUp;
                const down = keys.s || keys.ArrowDown;
                const left = keys.a || keys.ArrowLeft;
                const right = keys.d || keys.ArrowRight;
                const space = keys[' '];

                let currentAccel = ACCEL;
                if (this.superBoostTime > 0) currentAccel *= 3;

                if (up) {
                    this.velocity.x += Math.cos(this.angle) * currentAccel * dt;
                    this.velocity.y += Math.sin(this.angle) * currentAccel * dt;
                }
                if (down) {
                    this.velocity.x -= Math.cos(this.angle) * BRAKE * dt;
                    this.velocity.y -= Math.sin(this.angle) * BRAKE * dt;
                }
                if (space) {
                    this.velocity.x *= 0.95; this.velocity.y *= 0.95;
                }

                if (Math.abs(this.speed) > 50) {
                    let dir = this.speed > 0 ? 1 : -1;
                    if (left) this.angle -= STEER_SPEED * dt * dir;
                    if (right) this.angle += STEER_SPEED * dt * dir;
                }
            }

            handleBotAI(dt) {
                // Find nearest waypoint on track
                let closestIdx = 0;
                let minDist = Infinity;
                for(let i=0; i<waypoints.length; i++) {
                    let d = Math.hypot(this.x - waypoints[i].x, this.y - waypoints[i].y);
                    if (d < minDist) {
                        minDist = d;
                        closestIdx = i;
                    }
                }

                // AI aims for a waypoint slightly ahead of them on the track
                let targetIdx = (closestIdx + 8) % waypoints.length;
                const wp = waypoints[targetIdx];

                const dx = wp.x - this.x;
                const dy = wp.y - this.y;
                const targetAngle = Math.atan2(dy, dx);
                
                let angleDiff = targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                if (Math.abs(this.speed) > 50) {
                    if (angleDiff > 0.1) this.angle += STEER_SPEED * 0.8 * dt;
                    if (angleDiff < -0.1) this.angle -= STEER_SPEED * 0.8 * dt;
                }

                if (Math.abs(angleDiff) > 1.0 && this.speed > 400) {
                    this.velocity.x -= Math.cos(this.angle) * BRAKE * dt;
                    this.velocity.y -= Math.sin(this.angle) * BRAKE * dt;
                } else {
                    this.velocity.x += Math.cos(this.angle) * ACCEL * 0.8 * dt;
                    this.velocity.y += Math.sin(this.angle) * ACCEL * 0.8 * dt;
                }
            }

            isOnTrack() {
                let minDist = Infinity;
                for (let i = 0; i < waypoints.length; i++) {
                    const wp = waypoints[i];
                    const dist = Math.hypot(this.x - wp.x, this.y - wp.y);
                    if (dist < minDist) minDist = dist;
                }
                return minDist < MAPS[currentMapIndex].width;
            }

            checkLapProgress() {
                // Find closest track point to calculate sector progress
                let closestIdx = 0;
                let minDist = Infinity;
                for(let i=0; i<waypoints.length; i++) {
                    let d = Math.hypot(this.x - waypoints[i].x, this.y - waypoints[i].y);
                    if (d < minDist) {
                        minDist = d;
                        closestIdx = i;
                    }
                }

                // If on track, update sector logic
                if (minDist < MAPS[currentMapIndex].width * 2) {
                    // Divide track into 3 sectors (0, 1, 2)
                    let sector = Math.floor((closestIdx / waypoints.length) * 3); 
                    
                    // If moving from Sector 2 (end) to Sector 0 (start) = Completed a lap!
                    if (this.currentSector === 2 && sector === 0) {
                        this.lap++;
                        this.currentSector = 0; // Reset for next lap
                        
                        if (this.isLocal && !this.isBot) {
                            document.getElementById('lapDisplay').innerText = `${Math.min(this.lap, MAPS[currentMapIndex].laps)}/${MAPS[currentMapIndex].laps}`;
                        }
                        
                        if (this.lap > MAPS[currentMapIndex].laps) {
                            this.finishRace();
                        }
                    } 
                    // Normal progression to the next sector (e.g. 0 -> 1, or 1 -> 2)
                    else if (sector === (this.currentSector + 1) % 3) { 
                        this.currentSector = sector;
                    }
                    
                    // Fine-grain progress for accurate leaderboard positioning
                    this.progress = (this.lap - 1) + (closestIdx / waypoints.length);

                    // --- WRONG WAY DETECTION (Local Player Only) ---
                    if (this.isLocal && !this.isBot) {
                        let nextIdx = (closestIdx + 1) % waypoints.length;
                        let trackForwardX = waypoints[nextIdx].x - waypoints[closestIdx].x;
                        let trackForwardY = waypoints[nextIdx].y - waypoints[closestIdx].y;
                        
                        // Normalize the track forward vector
                        let mag = Math.hypot(trackForwardX, trackForwardY);
                        let nx = trackForwardX / mag;
                        let ny = trackForwardY / mag;
                        
                        // Calculate dot product (Velocity along the track direction)
                        let dot = (this.velocity.x * nx + this.velocity.y * ny);
                        
                        const wrongWayEl = document.getElementById('wrongWayWarning');
                        if (dot < -150) { // Moving backwards faster than 150 units
                            wrongWayEl.classList.remove('hidden');
                        } else {
                            wrongWayEl.classList.add('hidden');
                        }
                    }
                }
            }

            checkItems() {
                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    if (item.active && Math.hypot(this.x - item.x, this.y - item.y) < 60) {
                        item.active = false;
                        if (item.type === 'boost') {
                            this.superBoostTime = 2.0;
                        }
                        setTimeout(() => { item.active = true; }, 10000);
                    }
                }
            }

            finishRace() {
                this.finished = true;
                let finishedCount = Object.values(players).filter(p => p.finished && p.id !== this.id).length;
                this.placement = finishedCount + 1;
                
                if (this.isLocal && !this.isBot) {
                    document.getElementById('ui-postgame').classList.remove('hidden');
                    document.getElementById('finalPlacement').innerText = getOrdinal(this.placement);
                    document.getElementById('wrongWayWarning').classList.add('hidden'); // Ensure hidden at end
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Neon Underglow (Uses chosen color)
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.roundRect(-this.length/2 - 5, -this.width/2 - 5, this.length + 10, this.width + 10, 12);
                ctx.fill();
                
                // Reset styling for the car sprite
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0,0,0,0.6)';

                // Draw Car Image or fallback
                if (carSprite.complete && carSprite.naturalWidth > 0) {
                    ctx.save();
                    ctx.rotate(Math.PI/2); // Rotate sprite to face right natively
                    ctx.drawImage(carSprite, -this.width/2, -this.length/2, this.width, this.length);
                    ctx.restore();
                } else {
                    // Procedural fallback
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.roundRect(-this.length/2, -this.width/2, this.length, this.width, 8);
                    ctx.fill();
                    ctx.fillStyle = '#222'; ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.roundRect(-this.length/4, -this.width/2 + 4, this.length/2, this.width - 8, 4);
                    ctx.fill();
                }

                // Cosmetics
                ctx.shadowBlur = 0;
                ctx.rotate(Math.PI/2); 
                if (this.hat === 'cap') {
                    ctx.fillStyle = 'red';
                    ctx.beginPath(); ctx.arc(0, 5, 12, Math.PI, 0); ctx.fill();
                    ctx.fillRect(-12, 5, 24, 6); 
                } else if (this.hat === 'tophat') {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-15, 0, 30, 4); 
                    ctx.fillRect(-10, -15, 20, 15); 
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-10, -5, 20, 5); 
                } else if (this.hat === 'crown') {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-12, 5); ctx.lineTo(-15, -10); ctx.lineTo(-5, 0);
                    ctx.lineTo(0, -15); ctx.lineTo(5, 0); ctx.lineTo(15, -10);
                    ctx.lineTo(12, 5); ctx.closePath(); ctx.fill();
                }

                ctx.restore();

                // Name tag
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.fillText(this.name, this.x, this.y - 40);
                ctx.shadowBlur = 0;
            }
        }

        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        // --- TRACK GENERATION ---
        function generateWaypoints(mapIndex) {
            waypoints = [];
            const r = MAPS[mapIndex].trackRadius;
            
            if (mapIndex === 0) {
                // Circle/Oval
                for(let i=0; i<Math.PI*2; i+=0.2) {
                    waypoints.push({ x: Math.cos(i)*r, y: Math.sin(i)*r*0.6 });
                }
            } else if (mapIndex === 1) {
                // Figure 8 / Kidney
                for(let i=0; i<Math.PI*2; i+=0.1) {
                    let rMod = r * (1 + 0.3 * Math.sin(i*2));
                    waypoints.push({ x: Math.cos(i)*rMod, y: Math.sin(i)*rMod });
                }
            } else if (mapIndex === 2) {
                // Complex Winding
                for(let i=0; i<Math.PI*2; i+=0.05) {
                    let rMod = r * (1 + 0.4 * Math.sin(i*3) + 0.2 * Math.cos(i*5));
                    waypoints.push({ x: Math.cos(i)*rMod, y: Math.sin(i)*rMod });
                }
            } else if (mapIndex === 3) {
                // OCEAN HIGHWAY
                for(let i=0; i<Math.PI*2; i+=0.04) {
                    let x = Math.cos(i) * r * 2.5; 
                    let y = Math.sin(i) * r * 0.6 + Math.sin(i*6)*150; 
                    waypoints.push({ x: x, y: y });
                }
            }

            // Generate items
            items = [];
            for(let i=10; i<waypoints.length; i+=20) {
                items.push({ x: waypoints[i].x, y: waypoints[i].y, type: 'boost', active: true });
            }
        }

        function drawTrack() {
            const map = MAPS[currentMapIndex];
            
            // Draw background or procedural environment
            const img = loadedImages[map.bg];
            if (img && img.complete && img.naturalWidth > 0) {
                ctx.save();
                const scale = (map.trackRadius * 3) / img.width;
                ctx.translate(-map.trackRadius * 1.5, -map.trackRadius * 1.5);
                ctx.scale(scale, scale);
                ctx.globalAlpha = 0.5; 
                ctx.drawImage(img, 0, 0);
                ctx.restore();
            } else {
                if (currentMapIndex === 3) {
                    ctx.fillStyle = '#0284c7'; 
                    ctx.fillRect(-map.trackRadius*4, -map.trackRadius*4, map.trackRadius*8, map.trackRadius*8);
                } else {
                    ctx.fillStyle = '#1e293b'; 
                    ctx.fillRect(-map.trackRadius*2, -map.trackRadius*2, map.trackRadius*4, map.trackRadius*4);
                }
            }

            // Logical track outline
            ctx.strokeStyle = currentMapIndex === 3 ? '#1e293b' : '#334155'; 
            ctx.lineWidth = map.width * 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(waypoints[0].x, waypoints[0].y);
            for(let i=1; i<waypoints.length; i++) ctx.lineTo(waypoints[i].x, waypoints[i].y);
            ctx.closePath();
            ctx.stroke();

            // Guardrails for Ocean Highway
            if (currentMapIndex === 3) {
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x, waypoints[0].y - map.width);
                for(let i=1; i<waypoints.length; i++) ctx.lineTo(waypoints[i].x, waypoints[i].y - map.width);
                ctx.closePath(); ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x, waypoints[0].y + map.width);
                for(let i=1; i<waypoints.length; i++) ctx.lineTo(waypoints[i].x, waypoints[i].y + map.width);
                ctx.closePath(); ctx.stroke();
            }

            // Inner markings
            ctx.strokeStyle = currentMapIndex === 3 ? '#fbbf24' : '#cbd5e1'; 
            ctx.lineWidth = 6;
            ctx.setLineDash([60, 40]);
            ctx.beginPath();
            ctx.moveTo(waypoints[0].x, waypoints[0].y);
            for(let i=1; i<waypoints.length; i++) ctx.lineTo(waypoints[i].x, waypoints[i].y);
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);

            // === HOLOGRAPHIC FINISH LINE ===
            ctx.save();
            ctx.translate(waypoints[0].x, waypoints[0].y);
            const dx = waypoints[1].x - waypoints[0].x;
            const dy = waypoints[1].y - waypoints[0].y;
            ctx.rotate(Math.atan2(dy, dx) + Math.PI/2);
            
            // Glowing base line
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00f0ff';
            ctx.fillStyle = '#00f0ff';
            ctx.fillRect(-map.width, -4, map.width * 2, 8);
            
            // Holographic chevron pattern
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.8;
            const segments = 12;
            const segWidth = (map.width * 2) / segments;
            for(let i = 0; i < segments; i++) {
                let xPos = -map.width + (i * segWidth);
                
                // Top half chevron
                ctx.fillStyle = (i % 2 === 0) ? '#ff0055' : '#00f0ff';
                ctx.beginPath();
                ctx.moveTo(xPos, -15);
                ctx.lineTo(xPos + segWidth, -15);
                ctx.lineTo(xPos + segWidth - 10, 5);
                ctx.lineTo(xPos - 10, 5);
                ctx.fill();
                
                // Bottom half chevron
                ctx.fillStyle = (i % 2 === 0) ? '#00f0ff' : '#ff0055';
                ctx.beginPath();
                ctx.moveTo(xPos - 10, 5);
                ctx.lineTo(xPos + segWidth - 10, 5);
                ctx.lineTo(xPos + segWidth - 20, 25);
                ctx.lineTo(xPos - 20, 25);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Finish Line Edge Beacons/Pylons
            ctx.shadowBlur = 20;
            
            // Left Beacon
            ctx.shadowColor = '#ff0055';
            ctx.fillStyle = '#222';
            ctx.fillRect(-map.width - 25, -15, 25, 30);
            ctx.fillStyle = '#ff0055';
            ctx.beginPath(); ctx.arc(-map.width - 12, 0, 8, 0, Math.PI*2); ctx.fill();

            // Right Beacon
            ctx.shadowColor = '#00f0ff';
            ctx.fillStyle = '#222';
            ctx.fillRect(map.width, -15, 25, 30);
            ctx.fillStyle = '#00f0ff';
            ctx.beginPath(); ctx.arc(map.width + 12, 0, 8, 0, Math.PI*2); ctx.fill();

            ctx.restore();

            // Draw Items
            items.forEach(item => {
                if(item.active) {
                    ctx.fillStyle = '#ef4444'; 
                    ctx.shadowColor = 'red'; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.roundRect(item.x - 15, item.y - 15, 30, 30, 4); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.textAlign='center'; ctx.font='bold 20px Arial';
                    ctx.fillText('>>', item.x, item.y + 7);
                    ctx.shadowBlur = 0;
                }
            });
        }

        // --- GAME LOOP ---
        function updatePositionsAndUI() {
            let leaderboard = Object.values(players).sort((a,b) => b.progress - a.progress);
            if(players[localPlayerId]) {
                const pos = leaderboard.findIndex(p => p.id === localPlayerId) + 1;
                document.getElementById('positionDisplay').innerText = `Pos: ${pos}/${leaderboard.length}`;
                document.getElementById('speedDisplay').innerText = `${Math.floor(Math.abs(players[localPlayerId].speed)/10)} MPH`;
            }
        }

        function loop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            if (dt > 0.1) dt = 0.1; 
            lastTime = timestamp;

            if (gameState === 'PLAYING') {
                Object.values(players).forEach(p => p.update(dt));

                for(let i=skidmarks.length-1; i>=0; i--) {
                    skidmarks[i].life -= dt;
                    if(skidmarks[i].life <= 0) skidmarks.splice(i, 1);
                }
                for(let i=particles.length-1; i>=0; i--) {
                    particles[i].x += particles[i].vx * dt;
                    particles[i].y += particles[i].vy * dt;
                    particles[i].life -= dt;
                    if(particles[i].life <= 0) particles.splice(i, 1);
                }

                updatePositionsAndUI();

                const local = players[localPlayerId];
                if(local) {
                    ctx.save();
                    ctx.translate(canvas.width/2 - local.x, canvas.height/2 - local.y);
                    
                    drawTrack();

                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    skidmarks.forEach(s => {
                        ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI*2); ctx.fill();
                    });

                    particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;

                    Object.values(players).forEach(p => p.draw(ctx));

                    ctx.restore();
                }
            }

            requestAnimationFrame(loop);
        }

        // --- WEBSOCKET MULTIPLAYER LOGIC ---
        async function createRoom() {
            if(!socket) return alert("Connecting...");
            socket.emit('createRoom', {
                name: document.getElementById('playerName').value || 'Racer',
                color: document.getElementById('carColor').value,
                hat: document.getElementById('carHat').value,
                mapVote: parseInt(document.getElementById('mapVote').value)
            }, (response) => {
                if (response.success) {
                    joinRoomLogic(response.roomCode);
                } else {
                    alert('Failed to create room');
                }
            });
        }

        async function joinRoomBtn() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if(code.length > 0) joinRoomLogic(code);
        }

        async function joinRoomLogic(code) {
            if(!socket) return;
            currentRoomId = code;
            
            document.getElementById('ui-multiplayer').classList.add('hidden');
            document.getElementById('ui-lobby').classList.remove('hidden');
            document.getElementById('lobbyRoomCode').innerText = code;
            document.getElementById('btnStartGame').classList.add('hidden');
            document.getElementById('waitingMsg').classList.remove('hidden');

            // For WebSocket, only host can start
            socket.emit('joinRoom', {
                roomCode: code,
                name: document.getElementById('playerName').value || 'Racer',
                color: document.getElementById('carColor').value,
                hat: document.getElementById('carHat').value,
                mapVote: parseInt(document.getElementById('mapVote').value)
            }, (response) => {
                if (!response.success) {
                    alert(response.error || 'Failed to join room');
                    backToMain();
                }
            });

            // Listen for room state updates
            socket.off('roomState');
            socket.on('roomState', (data) => {
                if (data.code !== currentRoomId) return;
                
                const list = document.getElementById('playerList');
                list.innerHTML = '';
                document.getElementById('playerCount').innerText = data.players.length;
                
                let votes = [];
                data.players.forEach(p => {
                    const li = document.createElement('li');
                    li.innerText = `${p.name} ${p.id === socket.id ? '(You)' : ''}`;
                    li.style.color = p.color;
                    list.appendChild(li);
                    votes.push(p.mapVote);

                    if (gameState === 'PLAYING' && p.id !== socket.id) {
                        if(!players[p.id]) players[p.id] = new Car(p.id, false, p.name, p.color, p.hat);
                    }
                });

                // First player to join becomes host
                if (data.players[0]?.id === socket.id) {
                    isHost = true;
                    document.getElementById('btnStartGame').classList.remove('hidden');
                    document.getElementById('waitingMsg').classList.add('hidden');
                }
            });

            // Listen for game start
            socket.off('gameStart');
            socket.on('gameStart', (data) => {
                if (gameState !== 'PLAYING') {
                    currentMapIndex = data.mapIndex;
                    gameMode = 'MULTI';
                    startGameReal();
                }
            });

            // Listen for player updates
            socket.off('playerUpdate');
            socket.on('playerUpdate', (data) => {
                if (gameState === 'PLAYING' && data.id !== socket.id) {
                    if (players[data.id]) {
                        players[data.id].targetX = data.x;
                        players[data.id].targetY = data.y;
                        players[data.id].targetAngle = data.angle;
                        players[data.id].lap = data.lap;
                    }
                }
            });

            // Listen for map vote updates
            socket.off('mapVoteUpdate');
            socket.on('mapVoteUpdate', (data) => {
                currentMapIndex = data.mapIndex;
            });

            document.getElementById('mapVote').onchange = (e) => {
                socket.emit('updateMapVote', { mapVote: parseInt(e.target.value) });
            };
        }

        async function hostStartGame() {
            if(!isHost || !socket) return;
            socket.emit('startGame', {}, (response) => {
                if (response.success) {
                    currentMapIndex = 3; // Will be updated by server
                    gameMode = 'MULTI';
                }
            });
        }

        function getCollectionPath(type) {
            // Not used with WebSocket, but kept for compatibility
            return null;
        }

        function startGameReal() {
            gameState = 'PLAYING';
            document.getElementById('ui-lobby').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('wrongWayWarning').classList.add('hidden');

            generateWaypoints(currentMapIndex);
            players = {}; 

            const name = document.getElementById('playerName').value || 'Racer';
            const color = document.getElementById('carColor').value;
            const hat = document.getElementById('carHat').value;

            localPlayerId = gameMode === 'MULTI' ? user.uid : 'local';
            players[localPlayerId] = new Car(localPlayerId, true, name, color, hat);
            
            // Set starting lap display immediately
            document.getElementById('lapDisplay').innerText = `1/${MAPS[currentMapIndex].laps}`;

            let index = 0;
            if(gameMode === 'SINGLE') {
                const botNames = ['Speedy', 'Drifter', 'Crash'];
                const botColors = ['#ff0000', '#00ff00', '#ff00ff'];
                for(let i=0; i<3; i++) {
                    const bid = 'bot_'+i;
                    players[bid] = new Car(bid, false, botNames[i], botColors[i], 'none', true);
                    players[bid].x = waypoints[0].x - Math.cos(waypoints[0].x)*(index*100);
                    players[bid].y = waypoints[0].y - Math.sin(waypoints[0].y)*(index*100);
                    players[bid].angle = Math.atan2(waypoints[1].y-waypoints[0].y, waypoints[1].x-waypoints[0].x);
                    index++;
                }
            }
            
            players[localPlayerId].x = waypoints[0].x - Math.cos(waypoints[0].x)*(index*100);
            players[localPlayerId].y = waypoints[0].y - Math.sin(waypoints[0].y)*(index*100);
            players[localPlayerId].angle = Math.atan2(waypoints[1].y-waypoints[0].y, waypoints[1].x-waypoints[0].x);

            if(gameMode === 'MULTI') {
                setInterval(() => {
                    if(gameState === 'PLAYING' && socket) {
                        const p = players[localPlayerId];
                        socket.emit('updatePlayer', { 
                            x: p.x, 
                            y: p.y, 
                            angle: p.angle, 
                            lap: p.lap
                        });
                    }
                }, 100); 
            }

            lastTime = performance.now();
        }

        function startSingleplayer() {
            gameMode = 'SINGLE';
            currentMapIndex = parseInt(document.getElementById('mapVote').value);
            document.getElementById('ui-main').classList.add('hidden');
            startGameReal();
        }

        async function backToMain() {
            gameState = 'MENU';
            if(socket && currentRoomId) {
                socket.emit('leaveRoom');
            }
            currentRoomId = null; isHost = false;
            document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
            document.getElementById('ui-main').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('wrongWayWarning').classList.add('hidden');
        }

        // --- EVENTS & BINDINGS ---
        window.addEventListener('keydown', e => { 
            if(keys.hasOwnProperty(e.key)) keys[e.key] = true; 
            if(e.key.toLowerCase() === 'y' && gameState === 'PLAYING' && players[localPlayerId]) {
                players[localPlayerId].superBoostTime = 2.0; 
            }
        });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        document.getElementById('btnSingleplayer').onclick = () => {
            document.getElementById('ui-main').classList.add('hidden');
            document.getElementById('ui-lobby').classList.remove('hidden');
            document.getElementById('btnStartGame').classList.remove('hidden');
            document.getElementById('btnStartGame').innerText = "Start Singleplayer";
            document.getElementById('btnStartGame').onclick = startSingleplayer;
            document.getElementById('waitingMsg').classList.add('hidden');
            document.getElementById('lobbyRoomCode').innerText = "LOCAL BOTS";
            gameMode = 'SINGLE';
        };

        document.getElementById('btnMultiplayer').onclick = () => {
            if(!socket || socket.disconnected) return alert("Game server is offline. Please start the Node.js server first: npm install && npm start");
            document.getElementById('ui-main').classList.add('hidden');
            document.getElementById('ui-multiplayer').classList.remove('hidden');
            gameMode = 'MULTI';
        };

        document.getElementById('btnCreateRoom').onclick = createRoom;
        document.getElementById('btnJoinRoom').onclick = joinRoomBtn;
        document.getElementById('btnBackToMain').onclick = backToMain;
        document.getElementById('btnLeaveRoom').onclick = backToMain;
        document.getElementById('btnReturnLobby').onclick = backToMain;
        
        document.getElementById('btnStartGame').onclick = () => {
            if(gameMode === 'MULTI') hostStartGame();
            else startSingleplayer();
        };

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        requestAnimationFrame(loop);

    </script>
</body>
</html>